<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Agent - ADMI</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  <header>
    <img id="app-logo" src="https://raw.githubusercontent.com/DomSimone/ADMI232/refs/heads/main/static/logo.png" alt="African Development Models Initiative Logo">
    <h1>African Development Models Initiative</h1>
  </header>

  <nav>
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about-us.html">About Us</a></li>
        <li><a href="research-design-and-management.html">Research Design & Management</a></li>
        <li><a href="data-ingestion.html">Data Ingestion & Analysis</a></li>
        <li><a href="ai-agent.html" class="active">AI Agent</a></li>
        <li><a href="research-repository.html">Research Repository</a></li>
        <li><a href="terms-of-use.html">Terms of Use</a></li>restrictions
        <li><a href="contact-us.html">Contact Us</a></li>
        <li><a href="login.html">Login</a></li>
            <li><a href="http://localhost:63342/Stripper/frontend/index.html" target="_blank" rel="noopener noreferrer">Umbuzo</a></li>
    </ul>
  </nav>

  <main class="container">
    <div class="nav-tabs">
      <button class="tab active" data-tab="documents">
        <i data-lucide="file-text"></i> Document Processing
      </button>
      <button class="tab" data-tab="terminal">
        <i data-lucide="terminal"></i> Data Terminal
      </button>
    </div>

    <!-- Document Processing Panel -->
    <section id="documents" class="panel active">
      <div class="panel-grid">
        <div class="card upload-card">
          <h2><i data-lucide="upload"></i> Document Ingestion & Analysis</h2>
          <p class="card-desc">Upload PDF or CSV files for AI-powered extraction</p>
          <div class="dropzone" id="dropzone">
            <input type="file" id="fileInput" accept=".pdf,.csv" multiple hidden>
            <i data-lucide="upload-cloud" style="width: 48px; height: 48px; color: var(--primary-green); margin-bottom: 10px;"></i>
            <span class="dropzone-text">Drop files here or click to browse</span>
            <span class="dropzone-count" id="fileCount">No files selected</span>
            <div class="file-limits">
              <small>Max 20 files â€¢ Max 15MB per file</small>
            </div>
          </div>
          <div class="upload-actions">
            <button class="btn secondary" id="clearFilesBtn">
              <i data-lucide="x"></i> Clear Files
            </button>
          </div>
          <div class="file-list" id="fileList"></div>
        </div>

        <div class="card extract-card">
          <h2><i data-lucide="sparkles"></i> AI-Powered Extraction</h2>
          <p class="card-desc">Describe what data to extract (e.g., "Author, Title, Date, Publisher")</p>
          <textarea id="extractPrompt" placeholder="Enter extraction prompt...&#10;Example: Author, Title, Date Published, Institution"></textarea>
          <div class="format-row">
            <label>Output format:</label>
            <select id="outputFormat">
              <option value="table">Table View</option>
              <option value="json">JSON</option>
              <option value="csv">CSV</option>
            </select>
          </div>
          <button class="btn primary" id="extractBtn">
            <i data-lucide="sparkles"></i> Extract with AI
          </button>
        </div>

        <div class="card analog-card">
          <h2><i data-lucide="file-text"></i> Research Metadata</h2>
          <p class="card-desc">Upload research documents for metadata extraction and analysis</p>
          <div class="dropzone analog-dropzone" id="analogDropzone">
            <input type="file" id="analogFileInput" multiple accept=".pdf,.csv" hidden>
            <i data-lucide="file-plus" style="width: 32px; height: 32px; color: #666; margin-bottom: 8px;"></i>
            <span class="dropzone-text">Drop research files here</span>
            <span class="dropzone-count" id="analogFileCount">0 files</span>
          </div>
          <div class="analog-status" id="analogStatus"></div>
        </div>
      </div>

      <div class="card output-card">
        <h2><i data-lucide="check-circle"></i>Extract Results</h2>
        <div class="output-actions">
          <button class="btn small" id="copyOutput">
            <i data-lucide="copy"></i> Copy
          </button>
          <button class="btn small" id="downloadOutput">
            <i data-lucide="download"></i> Download CSV
          </button>
          <button class="btn small" id="downloadJson">
            <i data-lucide="download"></i> Download JSON
          </button>
        </div>
        <div id="extractOutput"><span class="placeholder">Upload a document and click "Extract with AI" to begin...</span></div>
      </div>
    </section>

    <!-- Data Terminal Panel -->
    <section id="terminal" class="panel">
      <div class="terminal-layout">
        <div class="card terminal-input-card">
          <h2><i data-lucide="database"></i> CSV Data Input</h2>
          <p class="card-desc">Paste raw CSV or upload a file</p>
          <div class="csv-input-row">
            <textarea id="csvInput" placeholder="Paste CSV data here...&#10;col1,col2,col3&#10;1,2,3&#10;4,5,6"></textarea>
            <div class="upload-csv">
              <input type="file" id="csvFileInput" accept=".csv" hidden>
              <button class="btn secondary" id="uploadCsvBtn">
                <i data-lucide="upload"></i> Upload CSV
              </button>
            </div>
          </div>
          <div class="command-row">
            <label><i data-lucide="terminal"></i> Command:</label>
            <input type="text" id="commandInput" placeholder="e.g. head, describe, linear regression on X vs Y, plot histogram of Z">
            <button class="btn primary" id="executeBtn">
              <i data-lucide="play"></i> Execute
            </button>
          </div>
        </div>

        <div class="card terminal-output-card">
          <h2><i data-lucide="bar-chart-2"></i> Terminal Output</h2>
          <div class="output-tabs">
            <button class="output-tab active" data-output="text">
              <i data-lucide="align-left"></i> Text
            </button>
            <button class="output-tab" data-output="chart">
              <i data-lucide="bar-chart"></i> Chart
            </button>
          </div>
          <pre id="terminalOutput"><span class="placeholder">Results will appear here...</span></pre>
          <div id="chartContainer" class="chart-container hidden">
            <canvas id="chartCanvas"></canvas>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 African Development Models Initiative. All rights reserved.</p>
    <p>A Patson Malisa Foundation Project.</p>
  </footer>
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="script.js"></script>
  <script>
    // Initialize Lucide Icons
    lucide.createIcons();
  </script>
  
  <!-- LangExtract Integration - Direct Python Backend Connection -->
  <script>
    /**
     * ============================================================
     * LANGEXTRACT INTEGRATION
     * Direct connection to Python langextract_service.py backend
     * ============================================================
     * 
     * This module provides:
     * 1. Direct file upload to Python backend
     * 2. Strict schema enforcement for consistent columns/rows
     * 3. Clean spreadsheet-style table rendering
     * 4. Proper CSV export with correct headers
     */

    // ============================================================
    // CONFIGURATION
    // ============================================================
    
    const PYTHON_API = 'http://127.0.0.1:5001';  // Python langextract service
    const NODE_API = 'http://127.0.0.1:5001';  // Node.js backend for terminal

    // ============================================================
    // PYDANTIC-STYLE SCHEMA DEFINITIONS (JavaScript mirrors Python)
    // ============================================================

    /**
     * Field - Represents a single field definition with validation
     * Mirrors Python: Field(description="...", type=str, default=...)
     */
    class Field {
      constructor(options = {}) {
        this.description = options.description || '';
        this.required = options.required !== false;
        this.type = options.type || 'string';
        this.default = options.default !== undefined ? options.default : null;
      }

      validate(value) {
        if (this.required && (value === null || value === undefined || value === '')) {
          return { valid: false, error: 'Field is required' };
        }
        if (!this.required && (value === null || value === undefined || value === '')) {
          return { valid: true, value: this.default };
        }
        return { valid: true, value: value };
      }
    }

    /**
     * BaseModel - Base class for schema models
     * Mirrors Python: class BaseModel(BaseModel)
     */
    class BaseModel {
      constructor(data = {}) {
        this._fields = this.constructor.getFields();
        for (const [fieldName, field] of Object.entries(this._fields)) {
          this[fieldName] = data.hasOwnProperty(fieldName) ? data[fieldName] : field.default;
        }
      }

      static getFields() {
        return this._fieldDefinitions || {};
      }

      modelDump() {
        const result = {};
        for (const fieldName of Object.keys(this._fields)) {
          if (this[fieldName] !== undefined) {
            result[fieldName] = this[fieldName];
          }
        }
        return result;
      }
    }

    /**
     * Record - A single row of extracted data
     * Mirrors Python Record class
     */
    class Record extends BaseModel {
      static _fieldDefinitions = {
        date: new Field({ description: 'ISO date found in doc', type: 'string', required: false }),
        entity: new Field({ description: 'Name of company or person', type: 'string', required: false }),
        amount: new Field({ description: 'Numerical value only', type: 'float', required: false, default: 0.0 })
      };

      static getFields() {
        return this._fieldDefinitions;
      }
    }

    /**
     * ExtractionContainer - Container holding multiple records
     * Mirrors Python ExtractionContainer class
     */
    class ExtractionContainer extends BaseModel {
      static _fieldDefinitions = {
        rows: new Field({ description: 'List of extracted records', type: 'array', required: true, default: [] }),
        headers: new Field({ description: 'Column headers', type: 'array', required: true, default: [] }),
        metadata: new Field({ description: 'Extraction metadata', type: 'object', required: false, default: {} }),
        schema_version: new Field({ description: 'Schema version', type: 'string', required: false, default: '1.0' })
      };

      static getFields() {
        return this._fieldDefinitions;
      }

      getRows() {
        return this.rows || [];
      }

      toDataFrame() {
        const rows = this.getRows();
        const headers = this.headers || (rows.length > 0 ? Object.keys(rows[0]) : []);
        return {
          headers,
          data: rows.map(row => headers.map(h => row[h] ?? ''))
        };
      }

      toCsv() {
        const { headers, data } = this.toDataFrame();
        if (headers.length === 0) return '';

        // Convert headers to Title Case
        const displayHeaders = headers.map(h => 
          h.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
        );

        const csvRows = [displayHeaders.join(',')];
        
        data.forEach(row => {
          const values = row.map(cell => {
            let cellStr = String(cell ?? '');
            if (cellStr.includes('"')) {
              cellStr = cellStr.replace(/"/g, '""');
            }
            if (cellStr.includes(',') || cellStr.includes('\n') || cellStr.includes('"')) {
              cellStr = `"${cellStr}"`;
            }
            return cellStr;
          });
          csvRows.push(values.join(','));
        });

        return csvRows.join('\n');
      }

      toJson(indent = 2) {
        return JSON.stringify({
          schema_version: this.schema_version,
          metadata: this.metadata,
          headers: this.headers,
          rows: this.rows
        }, null, indent);
      }

      getSummary() {
        return {
          total_records: this.rows?.length || 0,
          fields: this.headers || [],
          metadata: this.metadata,
          schema_version: this.schema_version
        };
      }
    }

    // ============================================================
    // OUTPUT RENDERER
    // ============================================================

    class ExtractionOutput {
      constructor(container) {
        this.container = container;
      }

      /**
       * Render as clean spreadsheet-style table
       */
      renderTable() {
        const { headers, data } = this.container.toDataFrame();
        if (headers.length === 0) {
          return '<div class="placeholder">No data to display</div>';
        }

        // Convert headers to Title Case for display
        const displayHeaders = headers.map(h => 
          h.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
        );

        let html = '<div class="table-container" style="overflow-x: auto;">';
        html += '<table class="extraction-table">';
        
        // Header row
        html += '<thead><tr>';
        displayHeaders.forEach(h => {
          html += `<th>${this.escapeHtml(h)}</th>`;
        });
        html += '</tr></thead>';

        // Data rows
        html += '<tbody>';
        data.forEach((row, idx) => {
          html += `<tr data-row="${idx}">`;
          row.forEach(cell => {
            html += `<td>${this.escapeHtml(String(cell ?? ''))}</td>`;
          });
          html += '</tr>';
        });
        html += '</tbody></table></div>';

        return html;
      }

      /**
       * Render summary card
       */
      renderSummary() {
        const summary = this.container.getSummary();
        return `
          <div class="extraction-summary">
            <div class="summary-item">
              <span class="summary-label">Total Records:</span>
              <span class="summary-value">${summary.total_records}</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Fields:</span>
              <span class="summary-value">${summary.fields.join(', ')}</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Schema Version:</span>
              <span class="summary-value">${summary.schema_version}</span>
            </div>
          </div>
        `;
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      downloadCsv(filename = 'extracted_data.csv') {
        const csv = this.container.toCsv();
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        this.downloadBlob(blob, filename);
      }

      downloadJson(filename = 'extracted_data.json') {
        const json = this.container.toJson();
        const blob = new Blob([json], { type: 'application/json' });
        this.downloadBlob(blob, filename);
      }

      downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    }

    // ============================================================
    // MAIN APPLICATION LOGIC
    // ============================================================

    // Global state
    let currentFile = null;
    let currentContainer = null;
    let currentOutput = null;

    document.addEventListener('DOMContentLoaded', () => {
      // Initialize Lucide icons
      lucide.createIcons();

      // Tab navigation
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');
        });
      });

      // ============================================================
      // FILE UPLOAD - Direct to Python Backend
      // ============================================================
      
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('fileInput');
      const fileCount = document.getElementById('fileCount');
      const fileList = document.getElementById('fileList');

      if (dropzone) {
        dropzone.addEventListener('click', () => fileInput.click());
        dropzone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropzone.classList.add('dragover');
        });
        dropzone.addEventListener('dragleave', () => {
          dropzone.classList.remove('dragover');
        });
        dropzone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropzone.classList.remove('dragover');
          if (e.dataTransfer.files.length) {
            if (e.dataTransfer.files.length === 1) {
              handleFileSelect(e.dataTransfer.files[0]);
            } else {
              handleMultipleFiles(e.dataTransfer.files);
            }
          }
        });
      }

      if (fileInput) {
        fileInput.addEventListener('change', (e) => {
          if (e.target.files.length === 1) {
            handleFileSelect(e.target.files[0]);
          } else if (e.target.files.length > 1) {
            handleMultipleFiles(e.target.files);
          }
        });
      }

      // Upload button functionality
      const clearFilesBtn = document.getElementById('clearFilesBtn');

      if (clearFilesBtn) {
        clearFilesBtn.addEventListener('click', () => {
          currentFile = null;
          window.selectedFiles = null;
          fileCount.textContent = 'No files selected';
          fileList.innerHTML = '';
        });
      }

      function handleFileSelect(file) {
        const ext = file.name.toLowerCase().split('.').pop();
        if (!['pdf', 'csv'].includes(ext)) {
          alert('Only PDF and CSV files are supported');
          return;
        }

        // Check file size (15MB limit)
        const maxSize = 15 * 1024 * 1024; // 15MB in bytes
        if (file.size > maxSize) {
          alert(`File size exceeds 15MB limit. Please select a smaller file.`);
          return;
        }

        currentFile = file;
        fileCount.textContent = file.name;
        fileList.innerHTML = `<div style="color: var(--primary-green);"><i data-lucide="file"></i> ${file.name} (${formatBytes(file.size)})</div>`;
        lucide.createIcons();
        startUploadBtn.disabled = false;
      }

      function handleMultipleFiles(files) {
        const allowedFiles = [...files].filter(f => /\.(pdf|csv)$/i.test(f.name));
        
        if (allowedFiles.length > 20) {
          alert('Maximum 20 files allowed. Please select fewer files.');
          return;
        }

        // Check file sizes
        const maxSize = 15 * 1024 * 1024; // 15MB in bytes
        const oversizedFiles = allowedFiles.filter(f => f.size > maxSize);
        
        if (oversizedFiles.length > 0) {
          alert(`The following files exceed the 15MB limit: ${oversizedFiles.map(f => f.name).join(', ')}`);
          return;
        }

        // Store files for processing
        window.selectedFiles = allowedFiles;
        fileCount.textContent = `${allowedFiles.length} files selected`;
        
        // Display file list
        fileList.innerHTML = allowedFiles.map(f => 
          `<div style="color: var(--primary-green); margin: 4px 0;"><i data-lucide="file"></i> ${f.name} (${formatBytes(f.size)})</div>`
        ).join('');
        lucide.createIcons();
        
        // Enable upload button
        startUploadBtn.disabled = false;
      }

      async function processFilesInBatches(files) {
        const batchSize = 5; // Process 5 files at a time
        const results = [];
        const errors = [];
        
        fileCount.textContent = `${files.length} files selected`;
        fileList.innerHTML = '';
        
        for (let i = 0; i < files.length; i += batchSize) {
          const batch = files.slice(i, i + batchSize);
          const batchPromises = batch.map(async (file) => {
            try {
              const result = await processSingleFile(file);
              return { file, result, error: null };
            } catch (error) {
              return { file, result: null, error: error.message };
            }
          });
          
          const batchResults = await Promise.all(batchPromises);
          results.push(...batchResults.filter(r => r.result));
          errors.push(...batchResults.filter(r => r.error));
          
          // Update UI with batch results
          updateFileList(batchResults);
          
          // Small delay between batches to prevent overwhelming the server
          if (i + batchSize < files.length) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
        // Combine all results
        if (results.length > 0) {
          combineResults(results.map(r => r.result));
        }
        
        if (errors.length > 0) {
          alert(`Some files failed to process: ${errors.map(e => e.file.name).join(', ')}`);
        }
      }

      async function processSingleFile(file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('prompt', extractPrompt.value.trim() || 'Extract all relevant data');

        const response = await fetch(`${PYTHON_API}/process`, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Extraction failed');
        }

        return result;
      }

      function updateFileList(results) {
        const listHtml = results.map(r => {
          if (r.error) {
            return `<div style="color: var(--error); margin: 4px 0;"><i data-lucide="x-circle"></i> ${r.file.name}: ${r.error}</div>`;
          } else {
            return `<div style="color: var(--primary-green); margin: 4px 0;"><i data-lucide="check-circle"></i> ${r.file.name}: ${r.result.extractions?.length || 0} records</div>`;
          }
        }).join('');
        
        fileList.innerHTML += listHtml;
        lucide.createIcons();
      }

      function combineResults(results) {
        if (results.length === 0) return;

        // Combine all extractions
        const allExtractions = results.flatMap(r => r.extractions || []);
        const allHeaders = [...new Set(results.flatMap(r => r.headers || []))];
        
        // Create combined container
        currentContainer = new ExtractionContainer({
          rows: allExtractions,
          headers: allHeaders,
          metadata: {
            batch_processing: true,
            total_files: results.length,
            combined_records: allExtractions.length
          },
          schema_version: '1.0'
        });

        // Create output renderer
        currentOutput = new ExtractionOutput(currentContainer);

        // Render based on output format
        renderOutput();
      }

      function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // ============================================================
      // EXTRACTION - Direct to Python Backend
      // ============================================================

      const extractBtn = document.getElementById('extractBtn');
      const extractPrompt = document.getElementById('extractPrompt');
      const outputFormat = document.getElementById('outputFormat');
      const extractOutput = document.getElementById('extractOutput');

      if (extractBtn) {
        extractBtn.addEventListener('click', async () => {
          const prompt = extractPrompt.value.trim();
          
          if (!currentFile) {
            alert('Please upload a PDF or CSV file first');
            return;
          }
          
          if (!prompt) {
            alert('Please enter an extraction prompt');
            return;
          }

          // Show loading state
          extractOutput.innerHTML = '<div class="loading"><i data-lucide="loader-2" class="spin"></i> Processing document with AI extraction...</div>';
          lucide.createIcons();
          extractBtn.disabled = true;

          try {
            // Create form data for direct Python backend
            const formData = new FormData();
            formData.append('file', currentFile);
            formData.append('prompt', prompt);

            // Call Python langextract service directly
            const response = await fetch(`${PYTHON_API}/process`, {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.error || `HTTP ${response.status}`);
            }

            const result = await response.json();

            if (!result.success) {
              throw new Error(result.error || 'Extraction failed');
            }

            // Create container from result
            currentContainer = new ExtractionContainer({
              rows: result.extractions || [],
              headers: result.headers || [],
              metadata: result.metadata || {},
              schema_version: '1.0'
            });

            // Create output renderer
            currentOutput = new ExtractionOutput(currentContainer);

            // Render based on output format
            renderOutput();

            console.log(`Extraction complete: ${result.extractions?.length || 0} records extracted`);

          } catch (error) {
            console.error('Extraction error:', error);
            extractOutput.innerHTML = `<div class="error-message" style="color: var(--error); padding: 16px;">
              <i data-lucide="alert-circle"></i> 
              <strong>Error:</strong> ${error.message}
              <br><small style="color: #666;">Make sure the Python service is running on port 5001</small>
            </div>`;
            lucide.createIcons();
          } finally {
            extractBtn.disabled = false;
          }
        });
      }

      function renderOutput() {
        if (!currentOutput || !currentContainer) return;

        const format = outputFormat.value;
        
        switch (format) {
          case 'csv':
            const csv = currentContainer.toCsv();
            extractOutput.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace;">${currentOutput.escapeHtml(csv)}</pre>`;
            break;
          case 'json':
            extractOutput.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace;">${currentOutput.escapeHtml(currentContainer.toJson())}</pre>`;
            break;
          case 'table':
          default:
            // Render summary + table
            extractOutput.innerHTML = currentOutput.renderSummary() + currentOutput.renderTable();
            break;
        }
      }

      // Output format change handler
      if (outputFormat) {
        outputFormat.addEventListener('change', renderOutput);
      }

      // ============================================================
      // DOWNLOAD HANDLERS
      // ============================================================

      const downloadOutput = document.getElementById('downloadOutput');
      const downloadJson = document.getElementById('downloadJson');
      const copyOutput = document.getElementById('copyOutput');

      if (downloadOutput) {
        downloadOutput.addEventListener('click', () => {
          if (!currentOutput) {
            alert('No data to download. Please extract data first.');
            return;
          }
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          currentOutput.downloadCsv(`extracted_data_${timestamp}.csv`);
        });
      }

      if (downloadJson) {
        downloadJson.addEventListener('click', () => {
          if (!currentOutput) {
            alert('No data to download. Please extract data first.');
            return;
          }
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          currentOutput.downloadJson(`extracted_data_${timestamp}.json`);
        });
      }

      if (copyOutput) {
        copyOutput.addEventListener('click', async () => {
          if (!currentContainer) {
            alert('No data to copy. Please extract data first.');
            return;
          }
          
          const format = outputFormat.value;
          const text = format === 'csv' ? currentContainer.toCsv() : currentContainer.toJson();
          
          try {
            await navigator.clipboard.writeText(text);
            copyOutput.innerHTML = '<i data-lucide="check"></i> Copied!';
            lucide.createIcons();
            setTimeout(() => {
              copyOutput.innerHTML = '<i data-lucide="copy"></i> Copy';
              lucide.createIcons();
            }, 2000);
          } catch (err) {
            alert('Failed to copy to clipboard');
          }
        });
      }

      // ============================================================
      // ANALOG METADATA UPLOAD
      // ============================================================

      const analogDropzone = document.getElementById('analogDropzone');
      const analogFileInput = document.getElementById('analogFileInput');
      const analogFileCount = document.getElementById('analogFileCount');
      const analogStatus = document.getElementById('analogStatus');

      if (analogDropzone) {
        analogDropzone.addEventListener('click', () => analogFileInput.click());
        analogDropzone.addEventListener('dragover', (e) => {
          e.preventDefault();
          analogDropzone.classList.add('dragover');
        });
        analogDropzone.addEventListener('dragleave', () => {
          analogDropzone.classList.remove('dragover');
        });
        analogDropzone.addEventListener('drop', (e) => {
          e.preventDefault();
          analogDropzone.classList.remove('dragover');
          if (e.dataTransfer.files.length) {
            handleAnalogUpload(e.dataTransfer.files);
          }
        });
      }

      if (analogFileInput) {
        analogFileInput.addEventListener('change', (e) => {
          if (e.target.files.length) {
            handleAnalogUpload(e.target.files);
          }
        });
      }

      async function handleAnalogUpload(files) {
        const allowed = [...files].filter(f => /\.(pdf|csv)$/i.test(f.name));
        analogFileCount.textContent = `${allowed.length} file(s)`;
        analogStatus.innerHTML = '<div style="color: #666;">Processing...</div>';

        // Process each file
        for (const file of allowed) {
          const formData = new FormData();
          formData.append('file', file);
          formData.append('prompt', 'Extract metadata: title, author, date, keywords');

          try {
            const response = await fetch(`${PYTHON_API}/process`, {
              method: 'POST',
              body: formData
            });
            const result = await response.json();
            
            if (result.success) {
              analogStatus.innerHTML += `<div style="margin-top: 8px; padding: 8px; background: var(--primary-green-light); border-radius: 4px;">
                <strong>${file.name}</strong>: ${result.extractions?.length || 0} records extracted
              </div>`;
            } else {
              analogStatus.innerHTML += `<div style="margin-top: 8px; color: var(--error);">${file.name}: ${result.error}</div>`;
            }
          } catch (err) {
            analogStatus.innerHTML += `<div style="margin-top: 8px; color: var(--error);">${file.name}: ${err.message}</div>`;
          }
        }
      }

      // ============================================================
      // DATA TERMINAL (uses Node.js backend)
      // ============================================================

      const csvInput = document.getElementById('csvInput');
      const csvFileInput = document.getElementById('csvFileInput');
      const uploadCsvBtn = document.getElementById('uploadCsvBtn');
      const commandInput = document.getElementById('commandInput');
      const executeBtn = document.getElementById('executeBtn');
      const terminalOutput = document.getElementById('terminalOutput');
      const chartContainer = document.getElementById('chartContainer');
      const chartCanvas = document.getElementById('chartCanvas');
      const outputTabs = document.querySelectorAll('.output-tab');

      let chartInstance = null;

      if (uploadCsvBtn) {
        uploadCsvBtn.addEventListener('click', () => csvFileInput.click());
      }

      if (csvFileInput) {
        csvFileInput.addEventListener('change', (e) => {
          const f = e.target.files?.[0];
          if (!f) return;
          const r = new FileReader();
          r.onload = () => { csvInput.value = r.result; };
          r.readAsText(f);
        });
      }

      outputTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          outputTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const showChart = tab.dataset.output === 'chart';
          chartContainer.classList.toggle('hidden', !showChart);
          terminalOutput.classList.toggle('hidden', showChart);
        });
      });

      if (executeBtn) {
        executeBtn.addEventListener('click', executeCommand);
      }

      if (commandInput) {
        commandInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') executeCommand();
        });
      }

      async function executeCommand() {
        const csvData = csvInput.value.trim();
        const command = commandInput.value.trim();
        
        if (!csvData) {
          alert('Paste or upload CSV data first');
          return;
        }
        if (!command) {
          alert('Enter a command');
          return;
        }

        try {
          const response = await fetch(`${NODE_API}/terminal/execute`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ csvData, command })
          });

          const res = await response.json();
          
          if (res.error) throw new Error(res.error);

          terminalOutput.innerHTML = '';
          terminalOutput.appendChild(document.createTextNode(res.textOutput || 'No output'));
          terminalOutput.classList.remove('hidden');
          chartContainer.classList.add('hidden');
          outputTabs.forEach(t => t.classList.remove('active'));
          outputTabs[0].classList.add('active');

          if (res.chartData) {
            if (res.command === 'linear_regression') renderRegressionChart(res.chartData);
            else if (res.command === 'histogram') renderHistogramChart(res.chartData);
          }
        } catch (err) {
          terminalOutput.innerHTML = '';
          terminalOutput.appendChild(document.createTextNode('Error: ' + err.message));
          terminalOutput.classList.remove('hidden');
          chartContainer.classList.add('hidden');
        }
      }

      function renderRegressionChart(data) {
        if (chartInstance) chartInstance.destroy();
        const ctx = chartCanvas.getContext('2d');
        const { x, y, slope, intercept } = data;
        const minX = Math.min(...x), maxX = Math.max(...x);
        const padding = (maxX - minX) * 0.1 || 1;
        const lineX = [minX - padding, maxX + padding];
        const lineY = lineX.map(xi => slope * xi + intercept);

        chartInstance = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [
              {
                label: 'Actual data',
                data: x.map((xi, i) => ({ x: xi, y: y[i] })),
                backgroundColor: 'rgba(88, 166, 255, 0.6)',
                borderColor: 'rgba(88, 166, 255, 1)',
                pointRadius: 6
              },
              {
                label: 'Regression line',
                data: lineX.map((xi, i) => ({ x: xi, y: lineY[i] })),
                type: 'line',
                borderColor: 'rgba(63, 185, 80, 1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: '#333' } } },
            scales: {
              x: { ticks: { color: '#666' }, grid: { color: '#e0e0e0' } },
              y: { ticks: { color: '#666' }, grid: { color: '#e0e0e0' } }
            }
          }
        });
      }

      function renderHistogramChart(data) {
        if (chartInstance) chartInstance.destroy();
        const ctx = chartCanvas.getContext('2d');
        chartInstance = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: data.labels,
            datasets: [{
              label: data.column || 'Count',
              data: data.values,
              backgroundColor: 'rgba(88, 166, 255, 0.5)',
              borderColor: 'rgba(88, 166, 255, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: '#333' } } },
            scales: {
              x: { ticks: { color: '#666', maxRotation: 45 }, grid: { color: '#e0e0e0' } },
              y: { ticks: { color: '#666' }, grid: { color: '#e0e0e0' } }
            }
          }
        });
      }

      // ============================================================
      // SERVICE HEALTH CHECK
      // ============================================================

      async function checkServiceHealth() {
        try {
          const response = await fetch(`${PYTHON_API}/health`);
          const health = await response.json();
          console.log('Python service health:', health);
        } catch (err) {
          console.warn('Python service not available:', err.message);
          console.warn('Make sure to start the Python service: python workflows/langextract_service.py');
        }
      }

      // Check health on load
      checkServiceHealth();
    });

    // ============================================================
    // EXPORT CLASSES FOR EXTERNAL USE
    // ============================================================

    window.Field = Field;
    window.BaseModel = BaseModel;
    window.Record = Record;
    window.ExtractionContainer = ExtractionContainer;
    window.ExtractionOutput = ExtractionOutput;

    console.log('LangExtract Integration loaded');
    console.log('Python API:', PYTHON_API);
    console.log('Node API:', NODE_API);
  </script>

  <style>
    /* Additional styles for loading spinner */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 24px;
      color: var(--primary-green);
    }
    
    .spin {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Table container */
    .table-container {
      max-height: 500px;
      overflow: auto;
    }
    
    /* Error message */
    .error-message {
      background: #fee;
      border: 1px solid #fcc;
      border-radius: var(--radius);
      padding: 16px;
    }
  </style>
</body>
</html>
